{"version":3,"file":"index.js","sources":["../src/utils/index.js","../src/index.js"],"sourcesContent":["export function getType(value) {\n  switch (typeof value) {\n    case \"undefined\":\n      return undefined;\n    case \"number\":\n      return Number;\n    case \"boolean\":\n      return Boolean;\n    case \"object\":\n      if (value === null) return null;\n      if (Array.isArray(value)) return Array;\n      return Object;\n    case \"function\":\n      return Function;\n    case \"string\":\n    default:\n      return String;\n  }\n}\n\nexport function coerceToType(value, type) {\n  switch (type) {\n    case String:\n    case Number:\n      if (value == undefined) return;\n      return type(value);\n    case Boolean:\n      if (value === \"false\" || (!value && value !== \"\")) return false;\n      return true;\n    case Array:\n      if (Array.isArray(value)) return value;\n      if (typeof value === \"string\") {\n        return /^\\[.*\\]$/.test(value) ? JSON.parse(value) : [];\n      }\n      if (value) return type(value);\n      return [];\n    case Object:\n      return JSON.parse(value);\n    case Function:\n      return undefined;\n    default:\n      return undefined;\n  }\n}\n\nexport function setAttr(host, attrName, type, val, oldValue) {\n  if (val !== oldValue) {\n    switch (type) {\n      case null:\n      case undefined:\n        break;\n      case Boolean:\n        if (val) {\n          host.setAttribute(attrName, \"\");\n        } else {\n          host.removeAttribute(attrName);\n        }\n        break;\n      case Array:\n        if (val === undefined || val === null || val.length === 0) {\n          host.removeAttribute(attrName);\n        } else {\n          host.setAttribute(attrName, JSON.stringify(val));\n        }\n        break;\n      case Object:\n        if (\n          val === undefined ||\n          val === null ||\n          Object.keys(val).length === 0\n        ) {\n          host.removeAttribute(attrName);\n        } else {\n          host.setAttribute(attrName, JSON.stringify(val));\n        }\n        break;\n      case Function:\n        break;\n      case String:\n        if (val === \"\" || val === undefined || val === null) {\n          host.removeAttribute(attrName);\n        } else {\n          host.setAttribute(attrName, val);\n        }\n        break;\n      case Number:\n      default:\n        if (val === undefined || val === null) {\n          host.removeAttribute(attrName);\n        } else {\n          host.setAttribute(attrName, val);\n        }\n        break;\n    }\n  }\n}\n","import { property } from \"hybrids\";\nimport { camelToDash } from \"hybrids/src/utils\";\nimport { getType, coerceToType, setAttr } from \"./utils\";\n\n// Keep track of any instances of any components that use reflected attributes.\nconst hosts = new WeakMap();\n\n// Keep track of all reflected attributes, by component tag name.\nconst reflectedAttributes = new Map();\n\nexport default function reflect(value, methods = {}) {\n  let type;\n  let attrName;\n  let observer;\n  let reflectedValue = value;\n  const properties = {\n    ...property(reflectedValue, function connect(host, key) {\n      type = methods.type || getType(reflectedValue);\n      attrName = camelToDash(key);\n      const tagName = host.tagName;\n\n      // Set coerced value for key, as derived from attribute.\n      const attrValue = host.getAttribute(attrName);\n      if (attrValue !== null) {\n        reflectedValue = coerceToType(attrValue, type);\n        host[key] = reflectedValue;\n      }\n\n      // Assign all reflected attributes to a map whose lookup is the tagName.\n      const attrMap = reflectedAttributes.get(tagName) || new Map();\n      reflectedAttributes.set(tagName, attrMap.set(attrName, { key, type, defaultValue: reflectedValue }));\n\n      // Only assign a single mutation observer to watch any single host, no matter how many reflected keys it has.\n      const hasObserver = hosts.get(host);\n      if (!hasObserver) {\n        observer = new MutationObserver((mutations) => {\n          const watchedAttrs = reflectedAttributes.get(tagName);\n          mutations.forEach(({ attributeName, target }) => {\n            const watchedAttr = watchedAttrs.get(attributeName);\n            if (watchedAttr) {\n              const { key, type, defaultValue } = watchedAttr;\n              const attrValue = target.getAttribute(attributeName);\n              const reflectedValue = coerceToType(attrValue, type);\n              if (reflectedValue != undefined && reflectedValue !== host[key]) {\n                target[key] = reflectedValue;\n              }\n\n              // If the attribute has been removed, trigger the onRemoveAttribute method if available\n              if(!target.hasAttribute(attributeName) && methods.hasOwnProperty('onRemoveAttribute') && typeof methods.onRemoveAttribute === 'function') {\n                methods.onRemoveAttribute({\n                  host,\n                  target,\n                  key,\n                  reflectedValue,\n                  attrValue,\n                  defaultValue\n                });\n              }\n            }\n          });\n        });\n        hosts.set(host, true);\n        observer.observe(host, { attributes: true });\n      }\n\n      // Call any individually defined `connect` method the property may have.\n      let disconnectFn;\n      if (methods.connect) {\n        disconnectFn = methods.connect(host, key);\n      }\n\n      // Once a host disconnects, stop watching it and remove it from WeakMap.\n      // Only run code once no matter how many reflected keys it has.\n      return () => {\n        disconnectFn && disconnectFn();\n        if (observer) {\n          observer.disconnect();\n          hosts.delete(host);\n        }\n      };\n    }),\n  };\n  const _get = properties.get;\n  properties.get = (host, val = value) => {\n    return methods.get ? methods.get(host, val) : _get(host, val);\n  };\n  const _set = properties.set;\n  properties.set = (host, val, oldValue) => {\n    return methods.set\n      ? methods.set(host, val, oldValue)\n      : _set(host, val, oldValue);\n  };\n  properties.observe = (host, val, oldValue) => {\n    setAttr(host, attrName, type, val, oldValue);\n    if (methods.observe) methods.observe(host, val, oldValue);\n  };\n  return properties;\n}\n\nexport { getType, coerceToType };\n"],"names":["getType","value","Number","Boolean","Array","isArray","Object","Function","String","coerceToType","type","undefined","test","JSON","parse","setAttr","host","attrName","val","oldValue","setAttribute","removeAttribute","length","stringify","keys","hosts","WeakMap","reflectedAttributes","Map","observer","methods","reflectedValue","properties","property","key","camelToDash","tagName","attrValue","getAttribute","disconnectFn","attrMap","get","set","defaultValue","MutationObserver","mutations","watchedAttrs","forEach","attributeName","target","watchedAttr","hasAttribute","hasOwnProperty","onRemoveAttribute","observe","attributes","connect","disconnect","delete","_get","_set"],"mappings":"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"}